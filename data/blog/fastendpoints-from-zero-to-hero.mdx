---
title: 'FastEndpoints - From Zero to Hero'
date: '2025-10-17'
tags: ['dotnet', 'aspnet-core', 'fastendpoints', 'rest-api', 'csharp', 'architecture', 'vertical-slice-archtecture', 'repr']
draft: false
summary: 'Master FastEndpoints from ground zero - build blazing-fast, maintainable REST APIs with vertical slice architecture, comprehensive validation, and enterprise-grade features in .NET.'
images: ['/static/images/fastendpoints-from-zero-to-hero/banner.png']
layout: PostLayout
canonicalUrl: https://www.dandoescode.com/blog/fastendpoints-from-zero-to-hero
---

![Banner](/static/images/fastendpoints-from-zero-to-hero/banner.png)

<TOCInline toc={props.toc} exclude="Overview" toHeading={3} />

## Introduction

I've been building REST APIs with ASP.NET Core for years using Minimal APIs, and honestly, they've been a breath of fresh air compared to the controller-based approach. No more bloated controllers, no attribute soup, just clean, simple route handlers. It works well! üëç

But as I've embraced **Vertical Slice Architecture** (VSA) more and more in my projects, I started noticing a pattern. Developers in the community kept singing praises of **FastEndpoints** when used with VSA. The feedback was overwhelmingly positive - people were raving about how well it complements the vertical slice approach. Naturally, I was tempted to try it out. üòé

And wow, I'm glad I did! FastEndpoints takes everything I loved about Minimal APIs and supercharges it for vertical slices. Each endpoint becomes a self-contained class with its own request, response, validation, and business logic - perfectly aligned with VSA principles. No more hunting through multiple files to understand a single endpoint. No more scattered route handlers. Just clean, focused, testable slices. üôå

The combination of FastEndpoints and VSA has genuinely changed how I architect APIs. While Minimal APIs are great for simple scenarios, FastEndpoints shines when you need structure, scalability, and maintainability at an enterprise level.

In this comprehensive guide, I'll take you from absolute zero to FastEndpoints hero. We'll build a complete API from scratch, covering everything from basic CRUD operations to advanced features like validation, OpenAPI documentation, global preprocessors, commands, and events. Whether you're currently using Minimal APIs or traditional controllers, this guide will show you why FastEndpoints deserves a place in your toolkit.

## Prerequisites

Before diving in, make sure you have:

- **.NET 10 SDK or later** installed ([download here](https://dotnet.microsoft.com/download))
- **Your favorite IDE** (Rider, Visual Studio, or VS Code)
- **Basic C# knowledge** - understanding of async/await, records, and dependency injection
- **Familiarity with REST APIs** - HTTP methods, status codes, and JSON

Optional but recommended:
- **Postman or similar API client** for testing endpoints
- **Basic understanding of CQRS** - we'll use command/query patterns

## What Makes FastEndpoints Special?

Before we start coding, let's talk about why FastEndpoints deserves your attention:

‚úÖ **Vertical Slice Architecture** - Each endpoint lives in its own file with all related logic  
‚úÖ **Performance** - Significantly faster than traditional MVC controllers (we're talking 2-3x faster)  
‚úÖ **Built-in Validation** - FluentValidation integration out of the box  
‚úÖ **Clean Code** - No more attribute soup or massive controller classes  
‚úÖ **OpenAPI Support** - First-class Swagger documentation with minimal configuration  
‚úÖ **REPR Pattern** - Request-Endpoint-Response pattern for ultimate clarity  
‚úÖ **Testability** - Each endpoint is an isolated unit, perfect for testing  

A quick note on **MediatR**: since moving to a commercial license, if you're using it to glue your Vertical Slice Architecture (requests, notifications, handler dispatch), FastEndpoints can usually replace it outright‚Äîbuilt‚Äëin request/response flow, validation pipeline, command-style endpoints, and event publishing. Dropping MediatR cuts cost, reduces moving parts, and keeps your slices lean. üí∏

Now let's build something! üöÄ

## Getting Started

Let's create a new Web API project and set up FastEndpoints from scratch.

### Creating the Project

Open your terminal and run:

```bash
dotnet new webapi -n FastWebApi
cd FastWebApi
```

### Installing FastEndpoints

Add the FastEndpoints package to your project:

```bash
dotnet add package FastEndpoints
dotnet add package FastEndpoints.Swagger
```

Your `.csproj` file should look like this:

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="FastEndpoints" Version="7.0.1" />
    <PackageReference Include="FastEndpoints.Swagger" Version="7.0.1" />
  </ItemGroup>
</Project>
```

### Configuring Program.cs

Replace the contents of `Program.cs` with this minimal setup:

```csharp
using FastEndpoints;
using FastEndpoints.Swagger;

var builder = WebApplication.CreateBuilder();

builder.Services
    .AddFastEndpoints()
    .SwaggerDocument();

var app = builder.Build();

app.UseFastEndpoints()
    .UseSwaggerGen();

app.Run();
```

That's it! üéâ Notice how clean this is compared to the traditional MVC setup - no controllers, no ConfigureServices method, just the essentials.

## Domain Setup

Before building our endpoints, let's create a simple domain model. We'll build a Monkey API because, well, monkeys are awesome. üêµ

Create the following structure:

```
Common/
  Domain/
    Monkeys/
      Monkey.cs
  Persistence/
    MonkeyRepository.cs
```

### The Monkey Entity

Create `Common/Domain/Monkeys/Monkey.cs`:

```csharp
namespace FastWebApi.Common.Domain.Monkeys;

public class Monkey
{
    public Guid Id { get; private set; }
    public int Age { get; private set; }
    public string Name { get; private set; } = null!;
    public Temperament Temperament { get; private set; }

    private Monkey() { }

    public static Monkey Create(string name, int age, Temperament temperament)
    {
        return new Monkey
        {
            Id = Guid.NewGuid(),
            Name = name,
            Age = age,
            Temperament = temperament
        };
    }
}

public enum Temperament
{
    Playful,
    Calm,
    Aggressive,
    Shy,
    Curious
}
```

Notice the private constructor and factory method - this is a common DDD pattern that ensures our entities are always created in a valid state.

### The Repository

Create `Common/Persistence/MonkeyRepository.cs`:

```csharp
namespace FastWebApi.Common.Persistence;

using Domain.Monkeys;

public class MonkeyRepository
{
    private readonly List<Monkey> _monkeys =
    [
        Monkey.Create("George", 5, Temperament.Playful),
        Monkey.Create("Charlie", 3, Temperament.Curious),
        Monkey.Create("Luna", 7, Temperament.Calm)
    ];

    public void Create(Monkey monkey)
    {
        _monkeys.Add(monkey);
    }

    public IReadOnlyList<Monkey> GetAll()
    {
        return _monkeys.AsReadOnly();
    }

    public Monkey? GetById(Guid id)
    {
        return _monkeys.FirstOrDefault(m => m.Id == id);
    }

    public bool Delete(Guid id)
    {
        var monkey = GetById(id);
        if (monkey is null) return false;
        
        _monkeys.Remove(monkey);
        return true;
    }
}
```

For this tutorial, we're using an in-memory list. In production, you'd use EF Core, Dapper, or your preferred data access library.

Register the repository in `Program.cs`:

```csharp
builder.Services
    .AddSingleton<MonkeyRepository>()  // Add this line
    .AddFastEndpoints()
    .SwaggerDocument();
```

## Adding a GET Endpoint

Now for the fun part - let's create our first endpoint! üéØ

Create `Features/Monkeys/GetMonkeysEndpoint.cs`:

```csharp
using FastEndpoints;
using FastWebApi.Common.Persistence;

namespace FastWebApi.Features.Monkeys;

public record GetMonkeysResponse(List<GetMonkeysResponse.MonkeyDto> Monkeys)
{
    public record MonkeyDto(Guid Id, string Name, int Age, string Temperament);
}

public class GetMonkeysEndpoint(MonkeyRepository repository) 
    : EndpointWithoutRequest<GetMonkeysResponse>
{
    public override void Configure()
    {
        Get("/api/monkeys");
        AllowAnonymous();
    }

    public override async Task HandleAsync(CancellationToken ct)
    {
        var monkeys = repository.GetAll()
            .Select(m => new GetMonkeysResponse.MonkeyDto(
                m.Id, 
                m.Name, 
                m.Age, 
                m.Temperament.ToString()))
            .ToList();

        await SendOkAsync(new GetMonkeysResponse(monkeys), ct);
    }
}
```

Let's break down what's happening here:

1. **Response DTO** - We define our contract using C# records (immutable, concise, perfect for DTOs)
2. **Endpoint Class** - Inherits from `EndpointWithoutRequest<TResponse>` since we don't need a request body
3. **Configure Method** - Defines the route and security settings
4. **HandleAsync Method** - Contains our business logic
5. **Primary Constructor** - Repository injected via constructor injection (C# 12 feature! üòé)

Run the application:

```bash
dotnet run
```

Navigate to `https://localhost:5001/swagger` and you'll see your endpoint automatically documented! Try it out:

```bash
curl https://localhost:5001/api/monkeys
```

Response:

```json
{
  "monkeys": [
    {
      "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "name": "George",
      "age": 5,
      "temperament": "Playful"
    },
    {
      "id": "7c9e6679-7425-40de-944b-e07fc1f90ae7",
      "name": "Charlie",
      "age": 3,
      "temperament": "Curious"
    },
    {
      "id": "a3bbfd21-5c4e-4c41-8d8a-2d8c5c5d1234",
      "name": "Luna",
      "age": 7,
      "temperament": "Calm"
    }
  ]
}
```

## Adding a CREATE Endpoint

Let's add functionality to create new monkeys. Create `Features/Monkeys/CreateMonkeyEndpoint.cs`:

```csharp
using FastEndpoints;
using FastWebApi.Common.Domain.Monkeys;
using FastWebApi.Common.Persistence;

namespace FastWebApi.Features.Monkeys;

public record CreateMonkeyRequest(string Name, int Age, Temperament Temperament);

public record CreateMonkeyResponse(Guid Id, string Name, int Age, string Temperament);

public class CreateMonkeyEndpoint(MonkeyRepository repository) 
    : Endpoint<CreateMonkeyRequest, CreateMonkeyResponse>
{
    public override void Configure()
    {
        Post("/api/monkeys");
        AllowAnonymous();
    }

    public override async Task HandleAsync(CreateMonkeyRequest req, CancellationToken ct)
    {
        var monkey = Monkey.Create(req.Name, req.Age, req.Temperament);
        repository.Create(monkey);

        var response = new CreateMonkeyResponse(
            monkey.Id,
            monkey.Name,
            monkey.Age,
            monkey.Temperament.ToString());

        await SendCreatedAtAsync<GetMonkeyByIdEndpoint>(
            new { id = monkey.Id },
            response,
            cancellation: ct);
    }
}
```

Key differences from the GET endpoint:

- Inherits from `Endpoint<TRequest, TResponse>` since we have both request and response
- Uses `Post()` verb
- Returns `201 Created` with a `Location` header pointing to the new resource
- The `SendCreatedAtAsync` method automatically generates the location header based on another endpoint

Test it:

```bash
curl -X POST https://localhost:5001/api/monkeys \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Bobo",
    "age": 4,
    "temperament": 0
  }'
```

## Adding Validation and Custom Logic

Now let's add proper validation using FluentValidation. FastEndpoints has this built-in! ‚úÖ

Update `CreateMonkeyEndpoint.cs`:

```csharp
using FastEndpoints;
using FluentValidation;
using FastWebApi.Common.Domain.Monkeys;
using FastWebApi.Common.Persistence;

namespace FastWebApi.Features.Monkeys;

public record CreateMonkeyRequest(string Name, int Age, Temperament Temperament);

public class CreateMonkeyValidator : Validator<CreateMonkeyRequest>
{
    public CreateMonkeyValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Monkey needs a name!")
            .MinimumLength(2).WithMessage("Name must be at least 2 characters")
            .MaximumLength(50).WithMessage("Name must not exceed 50 characters");

        RuleFor(x => x.Age)
            .GreaterThan(0).WithMessage("Age must be positive")
            .LessThan(50).WithMessage("That's one old monkey! Max age is 50");

        RuleFor(x => x.Temperament)
            .IsInEnum().WithMessage("Invalid temperament value");
    }
}

public record CreateMonkeyResponse(Guid Id, string Name, int Age, string Temperament);

public class CreateMonkeyEndpoint(MonkeyRepository repository) 
    : Endpoint<CreateMonkeyRequest, CreateMonkeyResponse>
{
    public override void Configure()
    {
        Post("/api/monkeys");
        AllowAnonymous();
    }

    public override async Task HandleAsync(CreateMonkeyRequest req, CancellationToken ct)
    {
        // Validation happens automatically before this method is called!
        
        // Custom business logic
        var existingMonkeys = repository.GetAll();
        if (existingMonkeys.Any(m => m.Name.Equals(req.Name, StringComparison.OrdinalIgnoreCase)))
        {
            AddError(m => m.Name, "A monkey with this name already exists");
            await SendErrorsAsync(cancellation: ct);
            return;
        }

        var monkey = Monkey.Create(req.Name, req.Age, req.Temperament);
        repository.Create(monkey);

        var response = new CreateMonkeyResponse(
            monkey.Id,
            monkey.Name,
            monkey.Age,
            monkey.Temperament.ToString());

        await SendCreatedAtAsync<GetMonkeyByIdEndpoint>(
            new { id = monkey.Id },
            response,
            cancellation: ct);
    }
}
```

The validator is automatically discovered and executed before `HandleAsync` runs. If validation fails, a `400 Bad Request` is returned automatically with detailed error messages.

Try sending invalid data:

```bash
curl -X POST https://localhost:5001/api/monkeys \
  -H "Content-Type: application/json" \
  -d '{
    "name": "A",
    "age": -5,
    "temperament": 99
  }'
```

Response:

```json
{
  "errors": {
    "name": ["Name must be at least 2 characters"],
    "age": ["Age must be positive"],
    "temperament": ["Invalid temperament value"]
  }
}
```

Beautiful! üé®

**Validation Without the Plumbing** - If you've used MediatR for validation, you know the pain: creating a custom pipeline behavior, scanning for validators at runtime, wiring up the correct one, executing it, mapping results into some intermediate response format, then translating that into proper HTTP status codes. It's a lot of ceremony for what should be straightforward. With FastEndpoints, all that plumbing vanishes. Validators are automatically discovered by convention, executed before your handler runs, and failures are immediately translated into `400 Bad Request` responses with properly formatted error details. No custom behaviors, no middleware, no manual mapping‚Äîit just works out of the box. ‚ú®

## Adding a DELETE Endpoint with Model Binding

Let's create a DELETE endpoint that demonstrates route parameter binding. Create `Features/Monkeys/DeleteMonkeyEndpoint.cs`:

```csharp
using FastEndpoints;
using FastWebApi.Common.Persistence;

namespace FastWebApi.Features.Monkeys;

public record DeleteMonkeyRequest
{
    public Guid Id { get; init; }
}

public class DeleteMonkeyEndpoint(MonkeyRepository repository) 
    : Endpoint<DeleteMonkeyRequest>
{
    public override void Configure()
    {
        Delete("/api/monkeys/{id}");
        AllowAnonymous();
    }

    public override async Task HandleAsync(DeleteMonkeyRequest req, CancellationToken ct)
    {
        var success = repository.Delete(req.Id);

        if (!success)
        {
            await SendNotFoundAsync(ct);
            return;
        }

        await SendNoContentAsync(ct);
    }
}
```

FastEndpoints automatically binds the `{id}` route parameter to the `Id` property in your request object. The binding is case-insensitive and supports various sources:

- Route parameters: `/api/monkeys/{id}`
- Query strings: `/api/monkeys?id=123`
- Headers: `X-Monkey-Id: 123`
- Request body: JSON properties

You can also create a GET by ID endpoint. Create `Features/Monkeys/GetMonkeyByIdEndpoint.cs`:

```csharp
using FastEndpoints;
using FastWebApi.Common.Persistence;

namespace FastWebApi.Features.Monkeys;

public record GetMonkeyByIdRequest
{
    public Guid Id { get; init; }
}

public record GetMonkeyByIdResponse(Guid Id, string Name, int Age, string Temperament);

public class GetMonkeyByIdEndpoint(MonkeyRepository repository) 
    : Endpoint<GetMonkeyByIdRequest, GetMonkeyByIdResponse>
{
    public override void Configure()
    {
        Get("/api/monkeys/{id}");
        AllowAnonymous();
    }

    public override async Task HandleAsync(GetMonkeyByIdRequest req, CancellationToken ct)
    {
        var monkey = repository.GetById(req.Id);

        if (monkey is null)
        {
            await SendNotFoundAsync(ct);
            return;
        }

        var response = new GetMonkeyByIdResponse(
            monkey.Id,
            monkey.Name,
            monkey.Age,
            monkey.Temperament.ToString());

        await SendOkAsync(response, ct);
    }
}
```

Test the delete:

```bash
curl -X DELETE https://localhost:5001/api/monkeys/{id}
```

## Adding Support for API Groups

As your API grows, organizing endpoints into logical groups becomes essential. FastEndpoints supports API versioning and grouping out of the box.

Create a base configuration class `Features/Monkeys/MonkeyGroup.cs`:

```csharp
using FastEndpoints;

namespace FastWebApi.Features.Monkeys;

public class MonkeyGroup : Group
{
    public MonkeyGroup()
    {
        Configure("api/monkeys", ep =>
        {
            ep.Description(x => x
                .WithTags("Monkeys")
                .Produces<ErrorResponse>(400)
                .Produces(401)
                .Produces(500));
        });
    }
}
```

Now update your endpoints to use the group. Update `GetMonkeysEndpoint.cs`:

```csharp
public class GetMonkeysEndpoint(MonkeyRepository repository) 
    : EndpointWithoutRequest<GetMonkeysResponse>
{
    public override void Configure()
    {
        Get("");  // Route is now relative to the group
        Group<MonkeyGroup>();
        AllowAnonymous();
        Description(x => x
            .WithSummary("Get all monkeys")
            .WithDescription("Retrieves a list of all monkeys in the sanctuary"));
    }

    // ... rest of the code
}
```

Update `CreateMonkeyEndpoint.cs`:

```csharp
public class CreateMonkeyEndpoint(MonkeyRepository repository) 
    : Endpoint<CreateMonkeyRequest, CreateMonkeyResponse>
{
    public override void Configure()
    {
        Post("");  // Relative to group
        Group<MonkeyGroup>();
        AllowAnonymous();
        Description(x => x
            .WithSummary("Create a new monkey")
            .WithDescription("Adds a new monkey to the sanctuary")
            .Accepts<CreateMonkeyRequest>("application/json")
            .Produces<CreateMonkeyResponse>(201)
            .ProducesProblemDetails(400));
    }

    // ... rest of the code
}
```

The benefits of grouping:

‚úÖ Consistent base routes  
‚úÖ Shared metadata and documentation  
‚úÖ Common error responses  
‚úÖ Better Swagger organization  
‚úÖ Version management support  

## Adding OpenAPI Documentation

FastEndpoints has excellent OpenAPI/Swagger support built-in. Let's enhance our documentation.

Update `Program.cs`:

```csharp
using FastEndpoints;
using FastEndpoints.Swagger;

var builder = WebApplication.CreateBuilder();

builder.Services
    .AddSingleton<MonkeyRepository>()
    .AddFastEndpoints()
    .SwaggerDocument(o =>
    {
        o.DocumentSettings = s =>
        {
            s.DocumentName = "v1";
            s.Title = "Monkey Sanctuary API";
            s.Version = "v1";
            s.Description = "A comprehensive API for managing our monkey sanctuary";
        };
    });

var app = builder.Build();

app.UseFastEndpoints(c =>
{
    c.Endpoints.RoutePrefix = "api";
})
.UseSwaggerGen(c =>
{
    c.Path = "/swagger/{documentName}/swagger.json";
});

app.Run();
```

Now let's add XML documentation for even better API docs. Update `FastWebApi.csproj`:

```xml
<PropertyGroup>
  <TargetFramework>net8.0</TargetFramework>
  <Nullable>enable</Nullable>
  <ImplicitUsings>enable</ImplicitUsings>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
  <NoWarn>$(NoWarn);1591</NoWarn>
</PropertyGroup>
```

Add XML comments to your endpoints:

```csharp
/// <summary>
/// Retrieves all monkeys from the sanctuary
/// </summary>
/// <returns>A list of all monkeys</returns>
public class GetMonkeysEndpoint(MonkeyRepository repository) 
    : EndpointWithoutRequest<GetMonkeysResponse>
{
    // ... implementation
}
```

Visit `/swagger` to see your beautifully documented API! üìö

## Adding Global Preprocessors

Preprocessors run before endpoint execution and are perfect for cross-cutting concerns like logging, authentication checks, or request enrichment.

Create `Common/Middleware/LoggingPreProcessor.cs`:

```csharp
using FastEndpoints;
using System.Diagnostics;

namespace FastWebApi.Common.Middleware;

public class LoggingPreProcessor<TRequest> : IGlobalPreProcessor
{
    private readonly ILogger<LoggingPreProcessor<TRequest>> _logger;

    public LoggingPreProcessor(ILogger<LoggingPreProcessor<TRequest>> logger)
    {
        _logger = logger;
    }

    public async Task PreProcessAsync(IPreProcessorContext context, CancellationToken ct)
    {
        var sw = Stopwatch.StartNew();
        
        _logger.LogInformation(
            "Starting request: {Method} {Path}",
            context.HttpContext.Request.Method,
            context.HttpContext.Request.Path);

        context.HttpContext.Items["RequestStopwatch"] = sw;
        
        await Task.CompletedTask;
    }
}
```

Create a post-processor `Common/Middleware/LoggingPostProcessor.cs`:

```csharp
using FastEndpoints;
using System.Diagnostics;

namespace FastWebApi.Common.Middleware;

public class LoggingPostProcessor<TRequest, TResponse> : IGlobalPostProcessor
{
    private readonly ILogger<LoggingPostProcessor<TRequest, TResponse>> _logger;

    public LoggingPostProcessor(ILogger<LoggingPostProcessor<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }

    public async Task PostProcessAsync(IPostProcessorContext context, CancellationToken ct)
    {
        if (context.HttpContext.Items["RequestStopwatch"] is Stopwatch sw)
        {
            sw.Stop();
            _logger.LogInformation(
                "Completed request: {Method} {Path} - {StatusCode} in {ElapsedMs}ms",
                context.HttpContext.Request.Method,
                context.HttpContext.Request.Path,
                context.HttpContext.Response.StatusCode,
                sw.ElapsedMilliseconds);
        }

        await Task.CompletedTask;
    }
}
```

Register in `Program.cs`:

```csharp
builder.Services
    .AddSingleton<MonkeyRepository>()
    .AddFastEndpoints(o =>
    {
        o.Assemblies = new[] { typeof(Program).Assembly };
    })
    .SwaggerDocument(/* ... */);

// After app.UseFastEndpoints()
app.UseFastEndpoints(c =>
{
    c.Endpoints.RoutePrefix = "api";
    c.Endpoints.Configurator = ep =>
    {
        ep.PreProcessors(Order.Before, new LoggingPreProcessor<object>());
        ep.PostProcessors(Order.After, new LoggingPostProcessor<object, object>());
    };
});
```

Now every request is logged with timing information! ‚è±Ô∏è

## Commands with Handlers and Middleware

Commands represent intentions to change state. Let's implement a proper command pattern for creating monkeys.

Create `Features/Monkeys/Commands/CreateMonkey.cs`:

```csharp
namespace FastWebApi.Features.Monkeys.Commands;

using Common.Domain.Monkeys;

public record CreateMonkeyCommand(string Name, int Age, Temperament Temperament);

public record CreateMonkeyResult(Guid Id, string Name, int Age, string Temperament);
```

Create the command handler `Features/Monkeys/Commands/CreateMonkeyHandler.cs`:

```csharp
using FastWebApi.Common.Persistence;
using FastWebApi.Common.Domain.Monkeys;

namespace FastWebApi.Features.Monkeys.Commands;

public class CreateMonkeyHandler
{
    private readonly MonkeyRepository _repository;
    private readonly ILogger<CreateMonkeyHandler> _logger;

    public CreateMonkeyHandler(
        MonkeyRepository repository,
        ILogger<CreateMonkeyHandler> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task<CreateMonkeyResult> HandleAsync(
        CreateMonkeyCommand command, 
        CancellationToken ct)
    {
        _logger.LogInformation("Creating monkey: {Name}", command.Name);

        var monkey = Monkey.Create(command.Name, command.Age, command.Temperament);
        _repository.Create(monkey);

        _logger.LogInformation("Monkey created successfully: {Id}", monkey.Id);

        return new CreateMonkeyResult(
            monkey.Id,
            monkey.Name,
            monkey.Age,
            monkey.Temperament.ToString());
    }
}
```

Now let's add command middleware for cross-cutting concerns. Create `Common/Commands/CommandLoggingMiddleware.cs`:

```csharp
namespace FastWebApi.Common.Commands;

public class CommandLoggingMiddleware<TCommand, TResult>
{
    private readonly ILogger<CommandLoggingMiddleware<TCommand, TResult>> _logger;

    public CommandLoggingMiddleware(ILogger<CommandLoggingMiddleware<TCommand, TResult>> logger)
    {
        _logger = logger;
    }

    public async Task<TResult> ExecuteAsync(
        TCommand command,
        Func<TCommand, CancellationToken, Task<TResult>> next,
        CancellationToken ct)
    {
        _logger.LogInformation(
            "Executing command: {CommandType}", 
            typeof(TCommand).Name);

        try
        {
            var result = await next(command, ct);
            
            _logger.LogInformation(
                "Command executed successfully: {CommandType}",
                typeof(TCommand).Name);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex,
                "Command execution failed: {CommandType}",
                typeof(TCommand).Name);
            throw;
        }
    }
}
```

Update the endpoint to use the handler:

```csharp
using FastEndpoints;
using FastWebApi.Features.Monkeys.Commands;

namespace FastWebApi.Features.Monkeys;

public class CreateMonkeyEndpoint : Endpoint<CreateMonkeyCommand, CreateMonkeyResult>
{
    private readonly CreateMonkeyHandler _handler;

    public CreateMonkeyEndpoint(CreateMonkeyHandler handler)
    {
        _handler = handler;
    }

    public override void Configure()
    {
        Post("");
        Group<MonkeyGroup>();
        AllowAnonymous();
    }

    public override async Task HandleAsync(CreateMonkeyCommand req, CancellationToken ct)
    {
        var result = await _handler.HandleAsync(req, ct);
        await SendCreatedAtAsync<GetMonkeyByIdEndpoint>(
            new { id = result.Id },
            result,
            cancellation: ct);
    }
}
```

Register the handler in `Program.cs`:

```csharp
builder.Services
    .AddSingleton<MonkeyRepository>()
    .AddScoped<CreateMonkeyHandler>()  // Register handler
    .AddFastEndpoints()
    .SwaggerDocument(/* ... */);
```

## Events with Handlers

Events represent things that have happened. Let's implement a domain event system for monkey creation.

Create `Common/Events/IDomainEvent.cs`:

```csharp
namespace FastWebApi.Common.Events;

public interface IDomainEvent
{
    DateTimeOffset OccurredAt { get; }
}
```

Create `Features/Monkeys/Events/MonkeyCreatedEvent.cs`:

```csharp
using FastWebApi.Common.Events;

namespace FastWebApi.Features.Monkeys.Events;

public record MonkeyCreatedEvent(
    Guid MonkeyId,
    string Name,
    int Age,
    string Temperament) : IDomainEvent
{
    public DateTimeOffset OccurredAt { get; } = DateTimeOffset.UtcNow;
}
```

Create an event handler `Features/Monkeys/Events/MonkeyCreatedEventHandler.cs`:

```csharp
using FastWebApi.Common.Events;

namespace FastWebApi.Features.Monkeys.Events;

public class MonkeyCreatedEventHandler
{
    private readonly ILogger<MonkeyCreatedEventHandler> _logger;

    public MonkeyCreatedEventHandler(ILogger<MonkeyCreatedEventHandler> logger)
    {
        _logger = logger;
    }

    public async Task HandleAsync(MonkeyCreatedEvent @event, CancellationToken ct)
    {
        _logger.LogInformation(
            "üêµ New monkey joined the sanctuary! Name: {Name}, Age: {Age}, Temperament: {Temperament}",
            @event.Name,
            @event.Age,
            @event.Temperament);

        // Here you could:
        // - Send notifications
        // - Update read models
        // - Trigger workflows
        // - Publish to message bus

        await Task.CompletedTask;
    }
}
```

Create a simple event publisher `Common/Events/EventPublisher.cs`:

```csharp
namespace FastWebApi.Common.Events;

public class EventPublisher
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<EventPublisher> _logger;

    public EventPublisher(IServiceProvider serviceProvider, ILogger<EventPublisher> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    public async Task PublishAsync<TEvent>(TEvent @event, CancellationToken ct) 
        where TEvent : IDomainEvent
    {
        _logger.LogInformation("Publishing event: {EventType}", typeof(TEvent).Name);

        // In a real application, you might use MediatR, MassTransit, or similar
        // For this demo, we'll just log
        var handlers = _serviceProvider.GetServices<IEventHandler<TEvent>>();
        
        foreach (var handler in handlers)
        {
            await handler.HandleAsync(@event, ct);
        }
    }
}

public interface IEventHandler<in TEvent> where TEvent : IDomainEvent
{
    Task HandleAsync(TEvent @event, CancellationToken ct);
}
```

Update the command handler to publish events:

```csharp
using FastWebApi.Common.Events;
using FastWebApi.Features.Monkeys.Events;

public class CreateMonkeyHandler
{
    private readonly MonkeyRepository _repository;
    private readonly EventPublisher _eventPublisher;
    private readonly ILogger<CreateMonkeyHandler> _logger;

    public CreateMonkeyHandler(
        MonkeyRepository repository,
        EventPublisher eventPublisher,
        ILogger<CreateMonkeyHandler> logger)
    {
        _repository = repository;
        _eventPublisher = eventPublisher;
        _logger = logger;
    }

    public async Task<CreateMonkeyResult> HandleAsync(
        CreateMonkeyCommand command, 
        CancellationToken ct)
    {
        _logger.LogInformation("Creating monkey: {Name}", command.Name);

        var monkey = Monkey.Create(command.Name, command.Age, command.Temperament);
        _repository.Create(monkey);

        // Publish domain event
        var @event = new MonkeyCreatedEvent(
            monkey.Id,
            monkey.Name,
            monkey.Age,
            monkey.Temperament.ToString());
        
        await _eventPublisher.PublishAsync(@event, ct);

        _logger.LogInformation("Monkey created successfully: {Id}", monkey.Id);

        return new CreateMonkeyResult(
            monkey.Id,
            monkey.Name,
            monkey.Age,
            monkey.Temperament.ToString());
    }
}
```

Register everything in `Program.cs`:

```csharp
builder.Services
    .AddSingleton<MonkeyRepository>()
    .AddScoped<CreateMonkeyHandler>()
    .AddScoped<EventPublisher>()
    .AddScoped<MonkeyCreatedEventHandler>()
    .AddFastEndpoints()
    .SwaggerDocument(/* ... */);
```

Now when you create a monkey, you'll see the event being published and handled in the logs! üéâ

## Summary

We've covered a ton of ground in this guide! Let's recap what we've built:

‚úÖ **Getting Started** - Set up a FastEndpoints project from scratch  
‚úÖ **Domain Setup** - Created a clean domain model with repository pattern  
‚úÖ **GET Endpoint** - Built a simple query endpoint with response DTOs  
‚úÖ **CREATE Endpoint** - Added POST functionality with proper HTTP responses  
‚úÖ **Validation** - Integrated FluentValidation for robust input validation  
‚úÖ **DELETE Endpoint** - Demonstrated model binding from route parameters  
‚úÖ **API Groups** - Organized endpoints with logical grouping  
‚úÖ **OpenAPI Documentation** - Generated beautiful, comprehensive API docs  
‚úÖ **Global Preprocessors** - Added cross-cutting logging and timing  
‚úÖ **Commands & Handlers** - Implemented CQRS pattern with command handling  
‚úÖ **Events & Handlers** - Built domain event system for decoupled architecture  

FastEndpoints has completely changed how I build APIs. The vertical slice architecture keeps code organized and maintainable as projects grow. Each endpoint is self-contained, making it easy to understand, test, and modify without affecting others. The performance is fantastic, the developer experience is smooth, and the built-in features (validation, OpenAPI, etc.) just work. üôå

Whether you're starting a new API or considering a migration from traditional controllers, FastEndpoints deserves serious consideration. The learning curve is minimal if you're familiar with ASP.NET Core, and the benefits are immediate and substantial.

Now go build something awesome! üöÄ

## Resources

- **FastEndpoints Documentation**: https://fast-endpoints.com/
- **Source Code**: https://github.com/FastEndpoints/FastEndpoints
- **Sample Project**: https://github.com/FastEndpoints/Examples
- **FluentValidation**: https://docs.fluentvalidation.net/
- **Vertical Slice Architecture**: https://www.jimmybogard.com/vertical-slice-architecture/
- **REPR Pattern**: https://deviq.com/design-patterns/repr-design-pattern

Have questions or want to share your FastEndpoints experience? Drop a comment below or find me on [Twitter/X](https://x.com/dandoescode)! I'd love to hear how you're using FastEndpoints in your projects. üòé
